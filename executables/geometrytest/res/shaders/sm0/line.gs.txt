// line.gs.txt

// #define SHOW_DEBUG_LINES        to show debug lines
// #define PASSTHROUGH_BASIC_LINES to show basic line primitiev
// #define STRIP                   to show proper filled wide line

layout(lines) in;

#if SHOW_DEBUG_LINES || PASSTHROUGH_BASIC_LINES
layout(line_strip, max_vertices = 10) out;
#else 
layout(triangle_strip, max_vertices = 6) out;
#endif

in vec3 position[];

out vec2    g_start;
out vec2    g_line;
out vec4    g_color;
out float   g_l2;

void main(void) 
{
   //  Wide line geometry shader
   //  Output quad (2 triangles) abcd for input line start..end
   //
   //  a - - -e- - - - - - - - - -f- - - b
   //  |      |                   |      |
   //  |      |                   |      |
   //  |      |                   |      |
   //  | - - -start - - - - - - end- - - |
   //  |      |                   |      |
   //  |      |                   |      |
   //  |      |                   |      |
   //  d - - -h- - - - - - - - - -g- - - c

   g_color = vec4(1.0, 1.0, 1.0, 1.0);

   vec3 start_in_model = gl_in[0].gl_Position.xyz;
   vec3 end_in_model   = gl_in[1].gl_Position.xyz;

   //  TODO: Use proper normals.
   //  These faked normals may kind of work for convex objects.
   vec3 start_normal_in_model = normalize(start_in_model);
   vec3 end_normal_in_model   = normalize(end_in_model);
   vec3 normal_in_model       = normalize(start_normal_in_model + end_normal_in_model);

   vec4 normal_in_clip = global.model_to_clip * vec4(normal_in_model, 0.0);
   vec4 start_in_clip  = global.model_to_clip * vec4(start_in_model, 1.0);
   vec4 end_in_clip    = global.model_to_clip * vec4(end_in_model, 1.0);

#if PASSTHROUGH_BASIC_LINES
   g_color = vec4(1.0, 1.0, 1.0, 1.0);
   gl_Position = start_in_clip; EmitVertex();
   gl_Position = end_in_clip;   EmitVertex();
   EndPrimitive();
   return;
#enif

   // It is necessary to manually clip the line before homogenization.
   // Compute line start and end distances to nearplane in clipspace
   // Distances are t0 = dot(start, plane) and t1 = dot(end, plane)
   // If signs are not equal then clip
   float t0 = start_in_clip.z + start_in_clip.w;
   float t1 = end_in_clip.z + end_in_clip.w;
   if (t0 < 0.0)
   {
       if(t1 < 0.0)
       {
           return;
       }
       start_in_clip = mix(start_in_clip, end_in_clip, (0 - t0) / (t1 - t0));
   }
   if (t1 < 0.0)
   {
       end_in_clip = mix(start_in_clip, end_in_clip, (0 - t0) / (t1 - t0));
   }

   vec2  vp_size            = global.viewport.zw;

   //  Find plane equation for the plane in clip space
   //  Plane equation: Ax + By + Cz + D = 0, Normal is (A, B, C)
   //  For any point (x, y, z) on plane:  D = -(Ax + By + Cz)
   float D                  = -dot(start_in_clip, normal_in_clip);
   float A                  = normal_in_clip.x;
   float B                  = normal_in_clip.y;
   float C                  = normal_in_clip.z;

   //  Move to ndc space
   vec3  start_in_ndc       = start_in_clip.xyz  / start_in_clip.w;
   vec3  end_in_ndc         = end_in_clip.xyz    / end_in_clip.w;
   vec3  line_in_ndc        = end_in_ndc - start_in_ndc;

   //  Move to window space
   vec2  start_in_window    = (0.5 * start_in_ndc.xy + vec2(0.5)) * vp_size + global.viewport.xy;
   vec2  end_in_window      = (0.5 * end_in_ndc.xy   + vec2(0.5)) * vp_size + global.viewport.xy;
   vec2  line_in_window     = line_in_ndc.xy * vp_size;             //  ndc to screen (direction vector)
   vec2  axis_in_window     = normalize(line_in_window);
   vec2  side_in_window     = vec2(-axis_in_window.y, axis_in_window.x);    // rotate

   //  Quad corners in window space
   vec2  a_in_window = start_in_window + (side_in_window - axis_in_window) * line_width.x * 0.5; 
   vec2  b_in_window = end_in_window   + (side_in_window + axis_in_window) * line_width.x * 0.5; 
   vec2  c_in_window = end_in_window   - (side_in_window - axis_in_window) * line_width.x * 0.5; 
   vec2  d_in_window = start_in_window - (side_in_window + axis_in_window) * line_width.x * 0.5; 
   vec2  e_in_window = start_in_window + (side_in_window                 ) * line_width.x * 0.5; 
   vec2  f_in_window = end_in_window   + (side_in_window                 ) * line_width.x * 0.5; 
   vec2  g_in_window = end_in_window   - (side_in_window                 ) * line_width.x * 0.5; 
   vec2  h_in_window = start_in_window - (side_in_window                 ) * line_width.x * 0.5; 

   //  Quad corners .xy in ndc
   vec2  a_in_2d_ndc = (a_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  b_in_2d_ndc = (b_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  c_in_2d_ndc = (c_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  d_in_2d_ndc = (d_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;

   vec2  e_in_2d_ndc = (e_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  f_in_2d_ndc = (f_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  g_in_2d_ndc = (g_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;
   vec2  h_in_2d_ndc = (h_in_window - viewport.xy + 0.5) / vp_size * 2.0 - 1.0;

#if 0
   //  Given known 2D positions and plane equation coefficients A, B, C and D, we can solve z
   //  Ax + By + Cz + D = 0
   //  Ax + By + D = -Cz
   //  z = (Ax + By + D) / -C
   float  az_in_ndc = ((A * a_in_2d_ndc.x) + (B * a_in_2d_ndc.y) + D) / -C;
   float  bz_in_ndc = ((A * b_in_2d_ndc.x) + (B * b_in_2d_ndc.y) + D) / -C;
   float  cz_in_ndc = ((A * c_in_2d_ndc.x) + (B * c_in_2d_ndc.y) + D) / -C;
   float  dz_in_ndc = ((A * d_in_2d_ndc.x) + (B * d_in_2d_ndc.y) + D) / -C;

   vec4 a = vec4(a_in_2d_ndc, az_in_ndc, 1.0) * az_in_ndc; 
   vec4 b = vec4(b_in_2d_ndc, bz_in_ndc, 1.0) * bz_in_ndc; 
   vec4 c = vec4(c_in_2d_ndc, cz_in_ndc, 1.0) * cz_in_ndc; 
   vec4 d = vec4(d_in_2d_ndc, dz_in_ndc, 1.0) * dz_in_ndc; 
#edif

#if 0
   //  Lines are visible but Z is wrong
   float fixed_w = 2.0;
   vec4 a = vec4(a_in_2d_ndc, 0.5, 1.0) * fixed_w; 
   vec4 b = vec4(b_in_2d_ndc, 0.5, 1.0) * fixed_w; 
   vec4 c = vec4(c_in_2d_ndc, 0.5, 1.0) * fixed_w; 
   vec4 d = vec4(d_in_2d_ndc, 0.5, 1.0) * fixed_w; 
#endif

#if 1
   //  This uses input line end point w coordinates for quad corners,
   //  2D positions are correct but Z is incorrect and fights with the
   //  input line (if wireframe is drawn on top of solid mesh for example).
   float axis_z_in_ndc      = line_in_ndc.z / length(line_in_ndc);
   vec3  axis_in_ndc        = vec3(axis_in_window.xy / vp_size, axis_z_in_ndc); // screen to NDC
   vec2  side_in_ndc        = side_in_window.xy / vp_size;
   vec4  axis               = vec4(axis_in_ndc.xy, 0.0, 0.0) * line_width.x;  // NDC to clip (delta vector)
   vec4  side               = vec4(side_in_ndc.xy, 0.0, 0.0) * line_width.x;

   vec4 a = (start_in_clip + (side - axis) * start_in_clip.w); 
   vec4 b = (end_in_clip   + (side + axis) * end_in_clip.w);
   vec4 c = (end_in_clip   - (side - axis) * end_in_clip.w);
   vec4 d = (start_in_clip - (side + axis) * start_in_clip.w);

   vec4 e = (start_in_clip + (side       ) * start_in_clip.w); 
   vec4 f = (end_in_clip   + (side       ) * end_in_clip.w);
   vec4 g = (end_in_clip   - (side       ) * end_in_clip.w);
   vec4 h = (start_in_clip - (side       ) * start_in_clip.w);
#endif

   //  Computations for fragment shader, which computes fragment distance
   //  to line segment
   g_start = start_in_window;
   g_line  = end_in_window - start_in_window;
   g_l2    = dot(g_line, g_line);

#if SHOW_DEBUG_LINES
# if 1
   g_color = vec4(0.5, 0.5, 1.0, 1.0);
   gl_Position = start_in_clip; EmitVertex();
   gl_Position = end_in_clip; EmitVertex();
   EndPrimitive();
#  endif

   g_color = vec4(1.0, 1.0, 0.5, 1.0);
#if 0
   gl_Position = a; EmitVertex(); gl_Position = b; EmitVertex(); EndPrimitive();
   gl_Position = b; EmitVertex(); gl_Position = c; EmitVertex(); EndPrimitive();
   gl_Position = c; EmitVertex(); gl_Position = d; EmitVertex(); EndPrimitive();
   gl_Position = d; EmitVertex(); gl_Position = a; EmitVertex(); EndPrimitive();
#else
   gl_Position = e; EmitVertex(); gl_Position = f; EmitVertex(); EndPrimitive();
   gl_Position = f; EmitVertex(); gl_Position = g; EmitVertex(); EndPrimitive();
   gl_Position = g; EmitVertex(); gl_Position = h; EmitVertex(); EndPrimitive();
   gl_Position = h; EmitVertex(); gl_Position = e; EmitVertex(); EndPrimitive();
#endif

#else

#if STRIP
# if 0
   gl_Position = d; EmitVertex();
   gl_Position = a; EmitVertex();
   gl_Position = c; EmitVertex();
   gl_Position = b; EmitVertex();
#else
   gl_Position = a; EmitVertex();
   gl_Position = d; EmitVertex();
   gl_Position = b; EmitVertex();
   gl_Position = c; EmitVertex();
#endif
   EndPrimitive();
#else
   gl_Position = d; EmitVertex();
   gl_Position = a; EmitVertex();
   gl_Position = c; EmitVertex();
   EndPrimitive();
   gl_Position = c; EmitVertex();
   gl_Position = a; EmitVertex();
   gl_Position = b; EmitVertex();
   EndPrimitive();
#endif

#endif
}